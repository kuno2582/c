/*

//비트 연산자
//-데이터를 비트단위로 처리하는 연산자
//-하드웨어와 관련된 처리를 쉽게 해줄 수 있습니다.
//-메모리 공간을 줄여서 성능을 높여 줄수 있습니다.

//비트연산자
//&	 	a & b	비트단위 AND 연산
//				두개의 비트가 모두 1일때 1을 반환

//피연산자	연산자	피연산자 	결과
//0			&		0		0
//0			&		1		0
//1			&		0		0
//1			&		1		1

//&연산자 vs 주소연산자(&)
//피연산자사이의 &		-> 비트 &연산자
//변수앞의 &			-> 주소연산자


//|	 	a | b 	비트단위 OR 연산
//				두개의 비트 중의 하나가 1일때 1을 반환
//피연산자	연산자	피연산자 	결과
//0			&		0		0
//0			&		1		1
//1			&		0		1
//1			&		1		1

//^		a ^ b	비트단위 XOR 연산
//				배타적 논리합
//				두 개의 비트가 서로 같지 않을 경우 1을 반환
//피연산자	연산자	피연산자 	결과
//0			&		0		0
//0			&		1		1
//1			&		0		1
//1			&		1		0


//~		~a		비트단위 NOT 연산
//				보수 연산으로 비트를 반전 시키게 됩니다.
//연산자	피연자 	결과
//~		0		1
//~		1		0



//<<	a<<3	왼쪽으로 세칸 이동
//				비트 왼쪽 이동

//>>	a>>1	오른쪽으로 한 칸 이동
//				비트 오른쪽 이동

#include <stdio.h>


int main(void){

	int a=12;
	//128 64 32 16 8 4 2 1
	//0   0  0  0  1 1 0 0

	int b=20;
	//128 64 32 16 8 4 2 1
	//0	  0  0  1  0 1 0 0

	int result1, result2, result3, result4;

	//& 연산자
	result1 = a & b;
	//0   0  0  0  1 1 0 0
	//0	  0  0  1  0 1 0 0
	//--------------------
	//0   0  0  0  0 1 0 0
	//128 64 32 16 8 4 2 1
	printf("a: %d\n", a);
	printf("b: %d\n", b);
	printf("비트단위 & 연산 결과: %d \n\n", result1);


	//| 연산자
	result2 = a | b;
	//0   0  0  0  1 1 0 0
	//0	  0  0  1  0 1 0 0
	//--------------------
	//0   0  0  1  1 1 0 0
	//128 64 32 16 8 4 2 1
	printf("a: %d\n", a);
	printf("b: %d\n", b);
	printf("비트단위 | 연산 결과: %d \n\n", result2);

	//^ 연산자
	result3 = a ^ b;
	//0   0  0  0  1 1 0 0
	//0	  0  0  1  0 1 0 0
	//--------------------
	//0   0  0  1  1 0 0 0
	//128 64 32 16 8 4 2 1
	printf("a: %d\n", a);
	printf("b: %d\n", b);
	printf("비트단위 ^연산 결과: %d \n\n", result3);

	//~ 연산자
	result4 = ~a;
	//0   0  0  0  1 1 0 0
	//--------------------
	//1   1  1  1  0 0 1 1

	printf("a: %d\n", a);
	printf("비트단위 ~연산결과: %d \n", result4);


	return 0;
}
*/
